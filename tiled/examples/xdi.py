"""
Example code for importing and exporting xdi using tiled

Source: https://github.com/XraySpectroscopy/XAS-Data-Interchange
"""

import collections
import io
import re

import dask
import pandas as pd

import tiled
from tiled.readers.dataframe import DataFrameAdapter

def serialize_xdi(dataframe, metadata):
    output = io.StringIO()

    xdi_version = metadata.get("xdi_version")
    comments = metadata.get("comments", "")
    extra_version = metadata.get("extra_version")

    output.write(f"# XDI/{xdi_version} {extra_version}\n")

    fields = metadata["fields"]
    for namespace, namespace_dict in fields.items():
        for tag, value in namespace_dict.items():
            output.write(f"# {namespace}.{tag}: {value}\n")

    output.write("# /////////////\n")
    output.write("# generated by tiled\n")
    output.write(comments)
    output.write("# -------------\n")

    # write column labels
    columns = list(dataframe.columns)
    output.write("# ")
    output.write(" ".join(columns))
    output.write("\n")

    # write data
    dataframe.to_csv(output, header=False, index=False)
    return output.getvalue()

class XDIDataFrameAdapter(DataFrameAdapter):
    specs = ["xdi"]

    @classmethod
    def from_xdi(cls, path):
        with open(path, "r") as f:
            metadata = {}
            fields = collections.defaultdict(dict)

            line = f.readline()
            m = re.match("# XDI/(\S*)\s*(\S*)?", line)
            if not m:
                raise AssertionError(f"not an XDI file, no XDI versioning information in first line\n{line}")

            metadata["xdi_version"] = m[1]
            metadata["extra_version"] = m[2]

            field_end_re = re.compile("#\s*/{3,}")
            header_end_re = re.compile("#\s*-{3,}")

            has_comments = False

            # read header
            for line in f:
                if line[0] != "#":
                    raise AssertionError(f"reached invalid line in header\n{line}")
                if re.match(field_end_re, line):
                    has_comments = True
                    break
                elif re.match(header_end_re, line):
                    break

                try:
                    key, val = line[1:].strip().split(":", 1)
                    val = val.strip()
                    namespace, tag = key.split(".")
                    #TODO coerce to lower case?
                except:
                    print(f"error processing line\n{line}")
                    raise

                fields[namespace][tag] = val

            if has_comments:
                comments = ""
                for line in f:
                    if re.match(header_end_re, line):
                        break
                    comments += line

                metadata["comments"] = comments

            metadata["fields"] = fields

            line = f.readline()
            if line[0] != "#":
                raise AssertionError(f"expected column labels. got\n{line}")
            col_labels = line[1:].split()

            # TODO validate

            df = pd.read_table(f, delim_whitespace=True, names=col_labels)

            return cls(dask.dataframe.from_pandas(df, npartitions=1), metadata=metadata)
